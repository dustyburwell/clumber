{"name":"Lumber","body":"# Lumber (v0.0.1) \r\n\r\n## Contents\r\n\r\n - [Overview](#overview)\r\n - [Features](#features)\r\n - [Dependencies](#dependencies)\r\n - [Installation](#installation)\r\n - [Running Tests](#tests)\r\n - [Usage](#usage)\r\n   - [Defaults](#defaults)\r\n   - [Multiple Transports](#multiple-transports)\r\n   - [Different Encoders](#different-encoders)\r\n   - [Customer Logging Levels](#custom-logging-levels)\r\n   - [Meta Data](#meta-data)\r\n   - [Format Params](#format-params)\r\n   - [Callbacks](#callbacks)\r\n   - [Events](#events)\r\n - [Options](#options)\r\n   - [Logger Options](#logger-options)\r\n   - [Transport Options](#transport-options)\r\n   - [Encoder Options](#encoder-options)\r\n - [TODO](#todo)\r\n\r\n## Overview\r\n\r\nLumber is an asynchronous logging library that is geared towards extensibility and providing an all-in-one\r\nsolution for logging in Node.js applications. It provides a method of logging to your CLI, a file log, or even\r\na webservice; each with independent configurable options.\r\n\r\nIt is possible with Lumber to have a verbose CLI, an error log, a debug log, and a webservice taking information\r\nlogs; each with a different encoder for their data; all with the same logger object.\r\n\r\n## Features\r\n\r\n - Isolated customizable logging transports\r\n - Customizable Encoders\r\n - Settings changes can be made on-the-fly\r\n\r\n## Dependencies\r\n\r\n - Node.js (0.6.x)\r\n - Npm (1.x.x)\r\n\r\n## Installation\r\n\r\nThe easiest way to install the Lumber module is with `npm`:\r\n\r\n```bash\r\nnpm install lumber\r\n```\r\n\r\nFor the bleeding edge build you can clone the repo and install:\r\n\r\n```bash\r\ngit clone git://github.com/englercj/lumber.git &&\r\ncd lumber &&\r\nnpm install\r\n```\r\n\r\n## Tests\r\n\r\nLumber comes with extensive unit tests written using [vows](http://vowsjs.org/). You can run\r\nthe test suite using:\r\n\r\n```bash\r\nnpm test\r\n```\r\n\r\nYou can also view code coverage, and build statistics at: [ci.pantherdev.com](http://ci.pantherdev.com/job/lumber/).\r\n\r\n## Usage\r\n\r\n### Defaults\r\n\r\nBy default lumber uses a console transport, with a text encoder. You can use it simply like:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger();\r\n\r\nlogger.log('info', 'Hey there!');\r\n//OR\r\nlogger.info('Hey there!');\r\n```\r\n\r\n### Multiple Transports\r\n\r\nTo use multiple transports, such as a console logger and a file. Simply specify them using the `transports` option:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger({\r\n    transports: [\r\n        new lumber.transports.Console(),\r\n\t\tnew lumber.transports.File()\r\n\t]\r\n});\r\n\t\r\nlogger.log('info', 'Hey there!');\r\n//OR\r\nlogger.info('Hey there!');\r\n```\r\n\r\nThis will print `info: Hey there!` to the console, as well as to the default file `app.log` (though the logfile will be in json). Another example is to have a verbose CLI, error log, and debug log:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger({\r\n    transports: [\r\n\t    new lumber.transports.Console({ level: 'verbose' }),\r\n\t\tnew lumber.transports.File({ filename: 'errors.log', level: 'error' }),\r\n\t\tnew lumber.transports.File({ filename: 'debug.log', level: 'debug' })\r\n\t]\r\n});\r\n\t\r\nlogger.info('Info message'); //logs to console & debug.log\r\nlogger.error('Error message'); //logs to console, debug.log, and errors.log\r\nlogger.debug('Debug message'); //logs to debug.log\r\n```\r\n\r\n### Different Encoders\r\n\r\nIf you don't like the default encoder chosen by a transport you can easily change it:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger({\r\n    transports: [\r\n\t    new lumber.transports.File({\r\n\t\t    filename: 'app.log',\r\n\t\t\tencoder: 'text'\r\n\t\t})\r\n\t]\r\n});\r\n```\r\n\r\nOr if you need to specify options on your own encoder, you can instantiate it instead of passing a string:\r\n\r\n```javascript\r\nvar logger = new lumber.Logger({\r\n    transports: [\r\n\t    new lumber.transports.File({\r\n\t\t    filename: 'app.log',\r\n\t\t\tencoder: new lumber.encoders.Text({\r\n\t\t\t    colorize: false,\r\n\t\t\t\theadFormat: '[%L] '\r\n\t\t\t})\r\n\t\t})\r\n\t]\r\n});\r\n```\r\n\r\n### Custom Logging Levels\r\n\r\nYou can pass your own levels and/or colors to a logger instance to override the defaults. Remember that any \r\nnegative log level will be considered a \"silent\" level, which allows for a state that the logger does not log anything:\r\n\r\n```javascript\r\nvar logger = new lumber.Logger({\r\n    levels: {\r\n\t    silent: -1,\r\n\t    error: 0,\r\n\t\tyoyo: 1,\r\n\t\tplease: 2\r\n\t},\r\n\tcolors: {\r\n\t    error: 'red',\r\n\t\tyoyo: 'rainbow',\r\n\t\tplease: 'grey'\r\n\t}\r\n});\r\n\t\r\n//now the logger has those levels as convenience functions\r\nlogger.yoyo('Yo Yo Yo!');\r\nlogger.please('fork me');\r\n\r\n//or you can specify them explicitly\r\nlogger.log('yoyo', 'some message');\r\n```\r\n\r\n### Meta Data\r\n\r\nSometime when you are logging an event (like an error) you may have some meta data that goes along with it (like the\r\nerror that was thrown). Lumber allows you to pass in this extra data to be logged along with you message:\r\n\r\n```javascript\r\nvar fs = require('fs'),\r\nlumber = require('lumber'),\r\nlogger = new lumber.Logger();\r\n\t\r\ntry {\r\n    fs.statSync('doesnt_exist.file');\r\n} catch(e) {\r\n    logger.error(e, 'File does not exist');\r\n\t//or logger.log('error', e, 'File does not exist');\r\n}\r\n```\r\n\r\n### Format Params\r\n\r\nLumber also allows you to use format params, that is you get the power of [`util.format`](http://nodejs.org/api/util.html#util_util_format) when using lumber:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger();\r\n\r\nlogger.info('You can insert strings: %s, or numbers: %d, or event json: %j', 'like this one', 15, { hi: 'there' });\r\n//or logger.log('info', 'You can insert strings: %s, or numbers: %d, or event json: %j', 'like this one', 15, { hi: 'there' });\r\n\t\r\n//You can still pass meta data if you want to:\r\nlogger.info({ meta: 'data' }, 'You can insert strings: %s, or numbers: %d, or event json: %j', 'like this one', 15, { hi: 'there' });\r\n//or logger.log('info', { meta: 'data' }, 'You can insert strings: %s, or numbers: %d, or event json: %j', 'like this one', 15, { hi: 'there' });\r\n```\r\n\r\n### Callbacks\r\n\r\nLumber is an asynchronous logger, so it provides a callback when it has finished logging to all of it's transports:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger({ transports: [new lumber.transports.Console(), new lumber.transports.File()] });\r\n\r\nlogger.info('A message', function(err) {\r\n    console.log('Error:', err);\r\n});\r\n//or logger.log('info', 'A message', function(err) {});\r\n\r\n//you can still specify meta data if you want\r\nlogger.info({ meta: 'data' }, 'A message', function(err) {\r\n    console.log('Error:', err);\r\n});\r\n//or logger.log('info', { meta: 'data' }, 'A message', function(err) {});\r\n\r\n//you can even continue to use format args\r\nlogger.info({ meta: 'data' }, 'A %s message', 'formatted', function(err) {\r\n    console.log('Error:', err);\r\n});\r\n//or logger.log('info', { meta: 'data' }, 'A %s message', 'formatted', function(err) {});\r\n```\r\n\r\n### Events\r\n\r\nLumber also is an instance of [`EventEmitter`](http://nodejs.org/api/events.html) and it will emit events as it logs to each transport.\r\nThe events you can listen for are:\r\n\r\n - `log`: emitted when finished logging to a transport (for multiple transports this will fire multiple times)\r\n - `logged`: emitted when finished logging to *all* transports.\r\n \r\nWhen the `logged` event is fired, it passes only an array of errors that occurred or `null` if no errors occurred:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger();\r\n\r\nlogger.info('hey there');\r\nlogger.on('logged', function(errors) {\r\n    if(errors) {\r\n\t    errors.forEach(function(err) {\r\n\t\t    console.log('Error:', err);\r\n\t\t});\r\n\t}\r\n});\r\n```\r\n\r\nThe `log` event is fired after each transport logs, and each transport will send the same base information:\r\n\r\n - `error`: The error if one occurred or `null` if no error occurred\r\n - `msg`: The encoded message that was logged\r\n - `level`: The level of the logged message\r\n - `name`: The transport's name that logged, `'console'` for `lumber.transports.Console`, `'file'` for `lumber.transports.File`, etc.\r\n\r\nSome transports will send extra information as well, here is the extra information for each transport:\r\n\r\n#### Console Transport\r\n\r\nNo extra information is sent.\r\n\r\n#### File Transport\r\n\r\n - `filename`: The resolved path to the file that was logged to\r\n \r\nExample:\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger({\r\n    transports: [\r\n\t    lumber.transports.Console(),\r\n\t    lumber.transports.File({ filename: 'errors.log', level: 'error' }),\r\n\t\tlumber.transports.File({ filename: 'full.log', level: 'silly' })\r\n\t]\r\n});\r\n\r\nlogger.info('hey there');\r\nlogger.on('log', function(err, msg, level, name, filename) {\r\n    //if this is the file transport that finished\r\n    if(name == 'file') {\r\n\t    if(filename.indexOf('errors.log') != -1) {\r\n\t\t    //this is the errors log that finished\r\n\t\t} else {\r\n\t\t    //this is the full log that finished\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n \r\n#### Webservice Transport\r\n\r\n - `url`: The url that the data was sent to\r\n - `statusCode`: The status code of the response from the webservice hit\r\n - `responseBody`: The body of the response from the webservice hit\r\n\r\n```javascript\r\nvar lumber = require('lumber'),\r\nlogger = new lumber.Logger({\r\n    transports: [\r\n\t    lumber.transports.Console(),\r\n\t    lumber.transports.Webservice({ url: 'http://myservice.com/service' })\r\n\t]\r\n});\r\n\r\nlogger.info('hey there');\r\nlogger.on('log', function(err, msg, level, name, url, statusCode, responseBody) {\r\n    //if this is the webservice transport that finished\r\n    if(name == 'webservice') {\r\n\t    if(statusCode == 200) {\r\n  \t\t    //for this example, lets assume our service returns JSON\r\n\t\t\tvar res = JSON.parse(responseBody);\r\n\t\t\t\r\n\t\t    console.log(res.somethingOrAnotherReturned);\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n\r\n## Options\r\n\r\n### Logger Options\r\n\r\nHere are all the options associated with a logger:\r\n\r\n - `levels`: Log levels associated with this logger, defaults to: `{ silent: -1, error: 0, warn: 1, info: 2, verbose: 3, debug: 4, silly: 5 }`\r\n - `colors`: Colors of levels in this logger, defaults to: `{ error: 'red', warn: 'yellow', info: 'cyan', verbose: 'magenta', debug: 'green', silly: 'grey' }`\r\n - `transports`: The transports for this logger, instantiated from `lumber.transports`, defaults to: `[new lumber.transports.Console()]`\r\n - `level`: The log level of this logger (can be overridden at the transport level), defaults to: `'info'`\r\n\r\n### Transport Options\r\n\r\nHere are the options common to all transports:\r\n\r\n - `encoder`: The encoder to use for this transport, defaults vary.\r\n - `level`: The log level of this transport, defaults to: logger level.\r\n \r\nEach Transport has it's own additional options and defaults as well, only differences from the common list are mentioned:\r\n\r\n#### Console Transport\r\n\r\n - `encoder`: defaults to: `'text'`\r\n\r\n#### File Transport\r\n\r\n - `encoder`: defaults to: `'json'`\r\n - `filename`: The filename to log to, defaults to: `'app.log'`\r\n \r\n#### Webservice Transport\r\n\r\n - `encoder`: defaults to: `'json'`\r\n - `url`: The URL of the webservice, like `http://domain.com/service`\r\n - `method`: The method of the request to the webservice, defaults to: `'POST'`\r\n - `headers`: The headers to send with the request, defaults to the encoder's content type.\r\n - `secure`: Whether or not to use SSL, must be set for https requests, defaults to: `false`\r\n - `auth`: Authentication for basic auth, in the format `username:password`\r\n \r\n### Encoder Options\r\n\r\nHere are the options common to all encoders:\r\n\r\n - `colorize`: Whether or not to apply the color scheme, defaults vary.\r\n - `timestamp`: Whether or not to apply a timestamp when encoding the log, defaults vary.\r\n - `headFormat`: The format of the message \"head\", the head is a formatted way of printing the log level of this message, defaults vary.\r\n - `dateFormat`: The format of the timestamps on logs, uses [node-dateformat](https://github.com/felixge/node-dateformat), defaults to: `'isoDateTime'`\r\n \r\nEach Encoder has it's own additional options and defaults as well, only differences from the common list are mentioned:\r\n\r\n#### Text Encoder\r\n\r\n - `colorize`: defaults to: `true`\r\n - `timestamp`: defaults to: `false`\r\n - `headFormat`: defaults to: `'%l: '`\r\n\r\n#### Json Encoder\r\n\r\n - `colorize`: currently has no effect\r\n - `timestamp`: defaults to: `true`\r\n - `headFormat`: defaults to: `'%L'`\r\n\r\n#### Xml Encoder\r\n\r\n - `colorize`: currently has no effect\r\n - `timestamp`: defaults to: `true`\r\n - `headFormat`: defaults to: `'%L'`\r\n\r\n## TODO\r\n\r\n - Special formatting for error meta data in text encoder\r\n - Stream log back into memory\r\n - Query log for information\r\n - Docs on writing custom encoders/transports\r\n - MongoDB / Redis transports\r\n","tagline":"A custom, async, extensible logging library","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}