// Generated by CoffeeScript 1.3.3

/*
@license
file.js: File transport

Liberal inspiration taken from https://github.com/flatiron/winston

(c) 2012 Panther Development
MIT LICENSE
*/


(function() {
  var File, events, fs, lumber, path, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require("util");

  fs = require("fs");

  path = require("path");

  events = require("events");

  lumber = require("../../lumber");

  /*
  File Transport
  @constructor
  @implements {Transport}
  */


  File = (function(_super) {

    __extends(File, _super);

    function File(options) {
      var e;
      if (options == null) {
        options = {};
      }
      this._flush = __bind(this._flush, this);

      File.__super__.constructor.call(this);
      this.encoder = lumber.util.checkOption(options.encoder, "json");
      this.level = lumber.util.checkOption(options.level, "info");
      this.filename = lumber.util.checkOption(options.filename, path.resolve("app.log"));
      this.filemode = lumber.util.checkOption(options.filemode, "0666");
      this.maxsize = lumber.util.checkOption(options.maxsize, 52428800);
      this.rotate = lumber.util.checkOption(options.rotate, 10);
      this._size = 0;
      this._buffer = [];
      this.name = "file";
      if (typeof this.encoder === "string") {
        e = lumber.util.titleCase(this.encoder);
        if (lumber.encoders[e]) {
          this.encoder = new lumber.encoders[e]();
        } else {
          throw new Error("Unknown encoder passed: " + this.encoder);
        }
      }
      this.encoding = this.encoder.encoding;
    }

    File.prototype.log = function(args, cb) {
      var msg,
        _this = this;
      msg = this.encoder.encode(args.level, args.msg, args.meta);
      return this._open(function(buff) {
        if (buff) {
          return _this._buffer.push([msg, args, cb]);
        } else {
          return _this._write(msg + "\n", function(err) {
            if (cb) {
              return cb(err, msg, args.level, _this.name, _this.filename);
            }
          });
        }
      });
    };

    File.prototype._write = function(data, cb) {
      var flushed,
        _this = this;
      this._size += data.length;
      flushed = this._stream.write(data, this.encoding);
      if (flushed) {
        if (this.maxsize && this._size >= this.maxsize) {
          return this._rotateLogs(function(err) {
            this._size = 0;
            if (cb) {
              return cb(err);
            }
          });
        } else {
          if (cb) {
            return cb(null);
          }
        }
      } else {
        return this._drain(function() {
          if (_this.maxsize && _this._size >= _this.maxsize) {
            return _this._rotateLogs(function(err) {
              _this._size = 0;
              if (cb) {
                return cb(err);
              }
            });
          } else {
            if (cb) {
              return cb(null);
            }
          }
        });
      }
    };

    File.prototype._open = function(cb) {
      var _this = this;
      if (this._opening) {
        if (cb) {
          return cb(true);
        }
      } else if (this._stream) {
        if (cb) {
          return cb(false);
        }
      } else {
        if (cb) {
          cb(true);
        }
        return this._checkSize(function(err) {
          _this._stream = fs.createWriteStream(_this.filename, {
            flags: "a",
            encoding: _this.encoding,
            mode: _this.fileMode
          });
          _this._stream.setMaxListeners(Infinity);
          _this.once("flush", function() {
            _this._opening = false;
            return _this.emit("open", _this.filename);
          });
          return _this._flush();
        });
      }
    };

    File.prototype._close = function(cb) {
      if (this._stream) {
        this._stream.end();
        this._stream.destroySoon();
        this._drain(function() {
          this.emit("closed");
          if (cb) {
            return cb(null);
          }
        });
        return this._stream = null;
      } else {
        this._stream = null;
        if (cb) {
          return cb(null);
        }
      }
    };

    File.prototype._drain = function(cb) {
      var _this = this;
      return this._stream.once("drain", function() {
        _this.emit("drain");
        if (cb) {
          return cb();
        }
      });
    };

    File.prototype._flush = function(cb) {
      var _this = this;
      if (this._buffer.length === 0) {
        this.emit("flush");
        if (cb) {
          cb(null);
        }
        return;
      }
      this._buffer.forEach(function(log) {
        var args, msg;
        console.log("buffer.foreach", log);
        msg = log[0], args = log[1], cb = log[2];
        return process.nextTick(function() {
          return _this._write(msg + "\n", function(err) {
            if (cb) {
              return cb(err, msg, args.level, _this.name, _this.filename);
            }
          });
        });
      });
      this._buffer.length = 0;
      return this._drain(function() {
        _this.emit("flush");
        if (cb) {
          return cb(null);
        }
      });
    };

    File.prototype._checkSize = function(cb) {
      return fs.stat(this.filename, function(err, stats) {
        if (err && err.code !== "ENOENT") {
          if (cb) {
            cb(err);
          }
          return;
        }
        this._size = (stats ? stats.size : 0);
        if (this._size >= this.maxsize) {
          this._size = 0;
          return this._rotateLogs(cb);
        } else {
          return cb(null);
        }
      });
    };

    File.prototype._rotateLogs = function(cb) {
      var exists, max;
      max = 1;
      exists = false;
      while (true) {
        try {
          fs.lstatSync(this.filename + "." + max);
          exists = true;
          max++;
        } catch (e) {
          exists = false;
        }
        if (!exists) {
          break;
        }
      }
      return this._close(function() {
        var _this = this;
        return this._doLogRotate(max, function(err) {
          if (err) {
            if (cb) {
              cb(err);
            }
            return;
          }
          _this.emit("rotate");
          if (max > _this.rotate) {
            return fs.unlink(_this.filename + "." + max, function(err) {
              if (cb) {
                return cb(err);
              }
            });
          } else {
            if (cb) {
              return cb(null);
            }
          }
        });
      });
    };

    File.prototype._doLogRotate = function(num, cb) {
      var from, to;
      if (!num) {
        if (cb) {
          cb(null);
        }
        return;
      }
      from = this.filename + (num > 1 ? "." + (num - 1) : "");
      to = this.filename + "." + num;
      return fs.rename(from, to, function(err) {
        if (err) {
          if (cb) {
            cb(err);
          }
          return;
        }
        num--;
        return this._doLogRotate(num, cb);
      });
    };

    return File;

  })(events.EventEmitter);

  module.exports.File = File;

}).call(this);
